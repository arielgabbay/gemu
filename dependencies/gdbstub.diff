diff -ruN -x .git arch_gb/gdbstub_sys.c arch_gb/gdbstub_sys.c
--- arch_gb/gdbstub_sys.c	1970-01-01 02:00:00.000000000 +0200
+++ arch_gb/gdbstub_sys.c	2020-04-13 09:21:18.854307144 +0300
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2016-2019 Matt Borgerson
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#include "gdbstub.h"
+
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <netinet/ip.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include "mmu.h"
+
+static address reg_offs[] = {
+	OFFSETOF(struct cpu_state, regs.flags),
+	OFFSETOF(struct cpu_state, regs.A),
+	OFFSETOF(struct cpu_state, regs.B),
+	OFFSETOF(struct cpu_state, regs.C),
+	OFFSETOF(struct cpu_state, regs.D),
+	OFFSETOF(struct cpu_state, regs.E),
+	OFFSETOF(struct cpu_state, regs.H),
+	OFFSETOF(struct cpu_state, regs.L),
+	OFFSETOF(struct cpu_state, regs.SP),
+	OFFSETOF(struct cpu_state, regs.PC),
+	OFFSETOF(struct cpu_state, rflags),
+	OFFSETOF(struct cpu_state, mclk),
+	OFFSETOF(struct cpu_state, tclk),
+};
+
+static address reg_sz[] = {
+	SIZEOF(struct cpu_state, regs.flags),
+	SIZEOF(struct cpu_state, regs.A),
+	SIZEOF(struct cpu_state, regs.B),
+	SIZEOF(struct cpu_state, regs.C),
+	SIZEOF(struct cpu_state, regs.D),
+	SIZEOF(struct cpu_state, regs.E),
+	SIZEOF(struct cpu_state, regs.H),
+	SIZEOF(struct cpu_state, regs.L),
+	SIZEOF(struct cpu_state, regs.SP),
+	SIZEOF(struct cpu_state, regs.PC),
+	SIZEOF(struct cpu_state, rflags),
+	SIZEOF(struct cpu_state, mclk),
+	SIZEOF(struct cpu_state, tclk),
+};
+
+static int sock = -1;
+static int csock = -1;
+static struct sockaddr_in caddr;
+
+size_t dbg_sys_get_reg_size(struct cpu_state * state, address addr) {
+	return reg_sz[addr];
+}
+
+char * dbg_sys_get_reg_ptr(struct cpu_state * state, address addr) {
+	return ((char *)state) + reg_offs[addr];
+}
+
+/*****************************************************************************
+ * Debugging System Functions
+ ****************************************************************************/
+
+static int check_conn() {
+	struct sockaddr_in serv_addr;
+	socklen_t client_addr_len;
+	if (csock < 0) {
+		if (sock < 0) {
+			printf("Creating server...\n");
+			sock = socket(AF_INET, SOCK_STREAM, 0);
+			if (sock < 0) {
+				printf("Creating socket failed\n");
+				goto err;
+			}
+			serv_addr.sin_family = AF_INET;
+			serv_addr.sin_addr.s_addr = INADDR_ANY;
+			serv_addr.sin_port = htons(32323);
+			if (bind(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
+				printf("Binding failed\n");
+				goto err;
+			}
+			listen(sock, 1);
+		}
+		printf("Waiting for connection...\n");
+		client_addr_len = sizeof(caddr);
+		csock = accept(sock, (struct sockaddr *)&caddr, &client_addr_len);
+		if (csock < 0) {
+			printf("Error establishing connection.\n");
+			goto err;
+		}
+		printf("Connection established!\n");
+	}
+	goto cleanup;
+err:
+	if (sock >= 0) {
+		close(sock);
+		sock = -1;
+	}
+	if (csock >= 0) {
+		close(csock);
+		csock = -1;
+	}
+	return 1;
+cleanup:
+	return 0;
+}
+
+/*
+ * Write one character to the debugging stream.
+ */
+int dbg_sys_putchar(int ch)
+{
+	unsigned char c = (unsigned char)(ch & 0xFF);
+	check_conn();
+	if (send(csock, &c, 1, 0) != 1) {
+		printf("Error sending char\n");
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * Read one character from the debugging stream.
+ */
+int dbg_sys_getc(void)
+{
+	unsigned char r;
+	check_conn();
+	if (recv(csock, &r, 1, 0) == -1) {
+		printf("Error receiving char: %u\n", errno);
+	}
+	return r;
+}
+
+/*
+ * Read one byte from memory.
+ */
+int dbg_sys_mem_readb(address addr, char *val)
+{
+	*val = read8(addr);
+	return 0;
+}
+
+/*
+ * Write one byte to memory.
+ */
+int dbg_sys_mem_writeb(address addr, char val)
+{
+	write8(addr, val);
+	return 0;
+}
+
+/*
+ * Continue program execution.
+ */
+int dbg_sys_continue(struct cpu_state * state)
+{
+	state->debugging = 0;
+	return 0;
+}
+
+/*
+ * Single step the next instruction.
+ */
+int dbg_sys_step(void)
+{
+	return 0;
+}
+
diff -ruN -x .git arch_gb/gdbstub_sys.h arch_gb/gdbstub_sys.h
--- arch_gb/gdbstub_sys.h	1970-01-01 02:00:00.000000000 +0200
+++ arch_gb/gdbstub_sys.h	2020-04-13 09:11:11.649962217 +0300
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2016-2019 Matt Borgerson
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef _GDBSTUB_SYS_H_
+#define _GDBSTUB_SYS_H_
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#include "cpu.h"
+
+/*****************************************************************************
+ * Types
+ ****************************************************************************/
+
+enum DBG_REGISTER {
+	DBG_CPU_GB_REG_FLAGS       = 0,
+	DBG_CPU_GB_REG_A           = 1,
+	DBG_CPU_GB_REG_B           = 2,
+	DBG_CPU_GB_REG_C           = 3,
+	DBG_CPU_GB_REG_D           = 4,
+	DBG_CPU_GB_REG_E           = 5,
+	DBG_CPU_GB_REG_H           = 6,
+	DBG_CPU_GB_REG_L           = 7,
+	DBG_CPU_GB_REG_SP          = 8,
+	DBG_CPU_GB_REG_PC          = 9,
+	DBG_CPU_GB_REG_RFLAGS      = 10,
+	DBG_CPU_GB_REG_MCLK        = 11,
+	DBG_CPU_GB_REG_TCLK        = 12,
+	DBG_CPU_GB_NUM_REGISTERS   = 13
+};
+
+typedef unsigned int address;
+typedef uint16_t reg;
+
+char * dbg_sys_get_reg_ptr(struct cpu_state *, address);
+size_t dbg_sys_get_reg_size(struct cpu_state *, address);
+int dbg_sys_getc(void);
+int dbg_sys_putchar(int ch);
+int dbg_sys_mem_readb(address addr, char *val);
+int dbg_sys_mem_writeb(address addr, char val);
+int dbg_sys_continue(struct cpu_state *);
+int dbg_sys_step();
+
+#endif
+
diff -ruN -x .git gdbstub.c gdbstub.c
--- gdbstub.c	2020-04-13 09:30:02.670830042 +0300
+++ gdbstub.c	2020-04-13 09:15:56.643833027 +0300
@@ -20,6 +20,8 @@
  * SOFTWARE.
  */
 
+#include <stdlib.h>
+
 #include "gdbstub.h"
 
 /*****************************************************************************
@@ -71,7 +73,11 @@
 /* Command functions */
 int dbg_mem_read(char *buf, size_t buf_len, address addr, size_t len, dbg_enc_func enc);
 int dbg_mem_write(const char *buf, size_t buf_len, address addr, size_t len, dbg_dec_func dec);
+#ifdef ARCH_GB
+int dbg_continue(struct cpu_state *);
+#else
 int dbg_continue(void);
+#endif
 int dbg_step(void);
 
 /*****************************************************************************
@@ -591,11 +597,18 @@
 /*
  * Continue program execution at PC.
  */
+#ifdef ARCH_GB
+int dbg_continue(struct cpu_state * state) {
+	dbg_sys_continue(state);
+	return 0;
+}
+#else
 int dbg_continue(void)
 {
 	dbg_sys_continue();
 	return 0;
 }
+#endif
 
 /*
  * Step one instruction.
@@ -739,7 +752,11 @@
 /*
  * Main debug loop. Handles commands.
  */
+#ifdef ARCH_GB
+int dbg_main(struct cpu_state * state)
+#else
 int dbg_main(struct dbg_state *state)
+#endif
 {
 	address     addr;
 	char        pkt_buf[256];
@@ -748,7 +765,7 @@
 	size_t      pkt_len;
 	const char *ptr_next;
 
-	dbg_send_signal_packet(pkt_buf, sizeof(pkt_buf), state->signum);
+	dbg_send_signal_packet(pkt_buf, sizeof(pkt_buf), 5);
 
 	while (1) {
 		/* Receive the next packet */
@@ -799,8 +816,12 @@
 		case 'g':
 			/* Encode registers */
 			status = dbg_enc_hex(pkt_buf, sizeof(pkt_buf),
+#ifdef ARCH_GB
+					     (char *)state, sizeof(*state));
+#else
 			                     (char *)&(state->registers),
 			                     sizeof(state->registers));
+#endif
 			if (status == EOF) {
 				goto error;
 			}
@@ -814,8 +835,12 @@
 		 */
 		case 'G':
 			status = dbg_dec_hex(pkt_buf+1, pkt_len-1,
+#ifdef ARCH_GB
+					     (char *)state, sizeof(*state));
+#else
 			                     (char *)&(state->registers),
 			                     sizeof(state->registers));
+#endif
 			if (status == EOF) {
 				goto error;
 			}
@@ -830,14 +855,23 @@
 			ptr_next += 1;
 			token_expect_integer_arg(addr);
 
+#ifdef ARCH_GB
+			if (addr >= DBG_CPU_GB_NUM_REGISTERS) {
+#else
 			if (addr >= DBG_CPU_I386_NUM_REGISTERS) {
+#endif
 				goto error;
 			}
 
 			/* Read Register */
 			status = dbg_enc_hex(pkt_buf, sizeof(pkt_buf),
+#ifdef ARCH_GB
+					     dbg_sys_get_reg_ptr(state, addr),
+					     dbg_sys_get_reg_size(state, addr));
+#else
 			                     (char *)&(state->registers[addr]),
 			                     sizeof(state->registers[addr]));
+#endif
 			if (status == EOF) {
 				goto error;
 			}
@@ -853,10 +887,19 @@
 			token_expect_integer_arg(addr);
 			token_expect_seperator('=');
 
+#ifdef ARCH_GB
+			if (addr < DBG_CPU_GB_NUM_REGISTERS) {
+#else
 			if (addr < DBG_CPU_I386_NUM_REGISTERS) {
+#endif
 				status = dbg_dec_hex(ptr_next, token_remaining_buf,
+#ifdef ARCH_GB
+						     dbg_sys_get_reg_ptr(state, addr),
+						     dbg_sys_get_reg_size(state, addr));
+#else
 				                     (char *)&(state->registers[addr]),
 				                     sizeof(state->registers[addr]));
+#endif
 				if (status == EOF) {
 					goto error;
 				}
@@ -928,7 +971,11 @@
 		 * Command Format: c [addr]
 		 */
 		case 'c':
+#ifdef ARCH_GB
+			dbg_continue(state);
+#else
 			dbg_continue();
+#endif
 			return 0;
 
 		/*
@@ -940,7 +987,7 @@
 			return 0;
 
 		case '?':
-			dbg_send_signal_packet(pkt_buf, sizeof(pkt_buf), state->signum);
+			dbg_send_signal_packet(pkt_buf, sizeof(pkt_buf), 5);
 			break;
 
 		/*
diff -ruN -x .git gdbstub.h gdbstub.h
--- gdbstub.h	2020-04-13 09:30:02.670830042 +0300
+++ gdbstub.h	2020-04-12 21:43:50.437586826 +0300
@@ -31,6 +31,10 @@
 /* Include platform specific definitions */
 #include "gdbstub_sys.h"
 
+#ifdef ARCH_GB
+#include "cpu.h"
+#endif
+
 /*****************************************************************************
  * Macros
  ****************************************************************************/
@@ -70,8 +74,13 @@
  * Prototypes
  ****************************************************************************/
 
-int dbg_main(struct dbg_state *state);
+#ifdef ARCH_GB
+int dbg_main(struct cpu_state *);
+#else
+int dbg_main(struct dbg_state *);
+#endif
 
+#ifndef ARCH_GB
 /* System functions, supported by all stubs */
 int dbg_sys_getc(void);
 int dbg_sys_putchar(int ch);
@@ -79,5 +88,7 @@
 int dbg_sys_mem_writeb(address addr, char val);
 int dbg_sys_continue();
 int dbg_sys_step();
+#endif
+
+#endif
 
-#endif
\ No newline at end of file
diff -ruN -x .git Makefile Makefile
--- Makefile	2020-04-13 09:30:02.666830064 +0300
+++ Makefile	2020-04-12 21:23:38.114552963 +0300
@@ -20,7 +20,7 @@
 # SOFTWARE.
 #
 
-ARCH := arch_x86
+ARCH := arch_gb
 
 # Include a simple demo that can be debugged
 INCLUDE_DEMO = 1
@@ -42,6 +42,8 @@
 CFLAGS  += -m32
 LDFLAGS += -m elf_i386
 OBJECTS += $(ARCH)/gdbstub_int.o
+else ifeq ($(ARCH),arch_gb)
+CFLAGS += -DARCH_GB
 else
 $(error Please specify a supported architecture)
 endif
